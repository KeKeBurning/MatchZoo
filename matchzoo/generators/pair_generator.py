"""Matchzoo pair generator."""

from matchzoo import engine
from matchzoo import datapack
from matchzoo import utils

import pandas as pd
import numpy as np
import typing


class PairGenerator(engine.BaseGenerator):
    """PairGenerator for Matchzoo.

    Pair generator can be used only for ranking.

    Examples:
        >>> relation = [['qid0', 'did0', 0],
        ...             ['qid0', 'did1', 1],
        ...             ['qid0', 'did2', 2]
        ...            ]
        >>> columns = ['id_left', 'id_right', 'label']
        >>> content = {'qid0': [1, 2],
        ...            'did0': [2, 3],
        ...            'did1': [3, 4],
        ...            'did2': [4, 5],
        ...           }
        >>> input = datapack.DataPack(relation=relation,
        ...                           content=content,
        ...                           columns=columns
        ...                           )
        >>> from matchzoo.generators import PairGenerator
        >>> generator = PairGenerator(input, 1, 1, 1, 'train', True)
        >>> assert generator
        >>> len(generator)
        2
        >>> x, y = generator[0]
        >>> assert x is not None
        >>> assert y is not None

    """

    def __init__(
        self,
        inputs: datapack.DataPack,
        num_neg: int=1,
        dup_time: int=4,
        batch_size: int=32,
        stage: str='train',
        shuffle: bool=True
    ):
        """Construct the pair generator.

        :param inputs: the output generated by :class:`DataPack`.
        :param num_neg: the number of negative samples associated with each
            positive sample.
        :param dup_time: the number of duplicates for each positive sample.
        :param batch_size: number of instances in a batch.
        :param shuffle: whether to shuffle the instances while generating a
            batch.
        """
        self._num_neg = num_neg
        self._dup_time = dup_time
        self._columns = inputs.relation.columns
        self.content = inputs.content
        self.pairs = self.transform_data(inputs.relation)
        super().__init__(batch_size, len(self.pairs), stage, shuffle)

    def transform_data(self, inputs: pd.DataFrame) -> dict:
        """Obtain the transformed data from :class:`DataPack`.

        Note here, label is required to make pairs.

        :param inputs: An instance of :class:`DataPack` to be transformed.
        :return: the output of all the transformed inputs.
        """
        if 'label' not in self._columns:
            raise ValueError(f"label is required from {inputs} \
                             to generate pairs.")
        # Note here the main id is set to be the id_left
        pairs = []
        for idx, group in inputs.sort_values('label', ascending=False).\
                groupby('id_left'):
            labels = group.label.unique()
            for label in labels:
                pos_samples = group[group.label == label]
                pos_samples = pd.concat([pos_samples] * self._dup_time)
                neg_samples = group[group.label < label]
                for _, pos_sample in pos_samples.iterrows():
                    if len(neg_samples) >= self._num_neg:
                        neg_sample = neg_samples.sample(self._num_neg,
                                                        replace=False)
                        pairs.append((pos_sample, [neg_sample]))
        return np.asarray(pairs)

    def _get_batch_of_transformed_samples(
        self,
        index_array: list
    ) -> typing.Tuple[dict, typing.Any]:
        """Get a batch of samples based on their ids.

        :param index_array: a list of instance ids.
        :return: A batch of transformed samples.
        """
        batch_x = {}
        batch_y = []
        for pos_sample, neg_samples in self.pairs[index_array]:
            batch_y.append(pos_sample['label'])
            for _, neg_sample in neg_samples[0].iterrows():
                batch_y.append(neg_sample['label'])
        num_ids = len(index_array) * (self._num_neg + 1)
        batch_x['ids'] = [[] for i in range(num_ids)]
        for key in self._columns:
            if key == 'label':
                continue
            batch_x[key] = []
            idx = 0
            for pos_sample, neg_samples in self.pairs[index_array]:
                batch_x[key].append(self.content[pos_sample[key]])
                batch_x['ids'][idx].append(pos_sample[key])
                idx += 1
                for _, neg_sample in neg_samples[0].iterrows():
                    batch_x[key].append(self.content[neg_sample[key]])
                    batch_x['ids'][idx].append(neg_sample[key])
                    idx += 1
            batch_x[key] = np.array(batch_x[key])
        batch_x = utils.dotdict(batch_x)
        return (batch_x, batch_y)
